(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{590:function(_,v,t){"use strict";t.r(v);var a=t(6),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("details",{staticClass:"custom-block details"},[t("summary",[_._v("Multithreading&Architecture")]),_._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#_1-java-i-o-演进之路"}},[_._v("1. Java I/O 演进之路")]),t("ul",[t("li",[t("a",{attrs:{href:"#_1-1-i-o-的问世"}},[_._v("1.1 I/O 的问世")])]),t("li",[t("a",{attrs:{href:"#_1-2-五种i-o通信模型"}},[_._v("1.2 五种I/O通信模型")])])])])])]),t("p")]),_._v(" "),t("h2",{attrs:{id:"_1-java-i-o-演进之路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-java-i-o-演进之路"}},[_._v("#")]),_._v(" 1. Java I/O 演进之路")]),_._v(" "),t("h3",{attrs:{id:"_1-1-i-o-的问世"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-i-o-的问世"}},[_._v("#")]),_._v(" 1.1 I/O 的问世")]),_._v(" "),t("h4",{attrs:{id:"_1-1-1-什么是i-o"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-什么是i-o"}},[_._v("#")]),_._v(" 1.1.1 什么是I/O")]),_._v(" "),t("p",[_._v("我们都知道在UNIX世界里一切皆文件，而文件是什么呢？文件就是一串二进制流而已，其实不管是"),t("code",[_._v("Socket")]),_._v("，还是FIFO (First Input First Output，先进先出队列)、管道、终端。对计算机来说，一切都是文件，一切都是流。在信息交换的过程中，计算机都是对这些流进行数据的收发操作，简称为I/O操作(Input and Output)，包括往流中读出数据、系统调用Read、写入数据、系统调用Write。不过计算机里有那么多流，怎么知道要操作哪个流呢？实际上是由操作系统内核创建"),t("code",[_._v("文件描述符")]),_._v("(File Descriptor，FD)来标识的，一个"),t("code",[_._v("FD")]),_._v("就是一个非负整数，所以对这个整数的操作就是对这个文件(流)的操作。我们创建一个"),t("code",[_._v("Socket")]),_._v("，通过系统调用会返回一个"),t("code",[_._v("FD")]),_._v("，那么剩下的对"),t("code",[_._v("Socket")]),_._v("的操作就会转化为对这个描述符的操作，这又是一种分层和抽象的思想。")]),_._v(" "),t("h4",{attrs:{id:"_1-1-2-i-o交互流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-i-o交互流程"}},[_._v("#")]),_._v(" 1.1.2 I/O交互流程")]),_._v(" "),t("p",[_._v("通常用户进程中的一次完整I/O交互流程分为两阶段，首先是经过内核空间，也就是由报系统处理:紧接着就是到用户空间，也就是交由应用程序。")]),_._v(" "),t("p",[_._v("![截屏2022-01-24 下午10.43.11](https://gitee.com/WWWWWWWXQ/images/raw/master/JCP-JUC/截屏2022-01-24 下午10.43.11.png)")]),_._v(" "),t("p",[_._v("内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中，Linux使用两级保护机制: 0级供内核(Kernel)使用，3级供用户程序使用。每个进程都有各自的私有用户空间("),t("code",[_._v("0-3G")]),_._v(")，这个空间对系统中的其他进程是不可见的。最高的"),t("code",[_._v("1G")]),_._v("字节虚拟内核空间则为所有进程及内核共享。")]),_._v(" "),t("p",[_._v("操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能简单地使用指传递数据。因为Linux使用的虚拟内存机制，必须通过系统调用请求Kernel来协助完成I/O操作，内核会为每个I/O设备维护一个缓冲区，用户空间的数据可能被换出，所以当内核空间使用用户空间的指针时，对应的数据可能不在内存中。")]),_._v(" "),t("p",[_._v("对于一个输入操作来说，进程I/O系统调用后，内核会先看缓冲区中有没有相应的缓存数据，如果没有再到设备中读取。因为设备I/O一般速度较慢，需要等待，内核缓冲区有数据则直接复制到进程空间。所以，一个网络输入操作通常包括两个不同阶段。")]),_._v(" "),t("ol",[t("li",[_._v("等待网络数据到达网卡，然后将数据读取到内核缓冲区。")]),_._v(" "),t("li",[_._v("从内核缓冲区复制数据，然后拷贝到用户空间。")])]),_._v(" "),t("p",[_._v("I/O有内存I/O、网络I/O和磁盘I/O三种，通常我们说的I/O指的是后两者。如下图所示I/O通信过程的调度示意。")]),_._v(" "),t("p",[_._v("![截屏2022-01-24 下午10.51.44](https://gitee.com/WWWWWWWXQ/images/raw/master/JCP-JUC/截屏2022-01-24 下午10.51.44.png)")]),_._v(" "),t("h3",{attrs:{id:"_1-2-五种i-o通信模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-五种i-o通信模型"}},[_._v("#")]),_._v(" 1.2 五种I/O通信模型")]),_._v(" "),t("p",[_._v("在网络环境下，通俗地讲，将I/O分为两步：第一步是等待；第二步是数据搬迁。")]),_._v(" "),t("p",[_._v("如果想要提高I/O效率，需要将等待时间降低。因此发展出来五种I/O模型，分别是：")]),_._v(" "),t("ul",[t("li",[_._v("阻塞I/O模型")]),_._v(" "),t("li",[_._v("非阻塞I/O模型")]),_._v(" "),t("li",[_._v("多路复用I/O模型")]),_._v(" "),t("li",[_._v("信号驱动I/O模型")]),_._v(" "),t("li",[_._v("异步I/O模型。")])]),_._v(" "),t("p",[_._v("其中，前四种被称为"),t("strong",[_._v("同步")]),_._v("I/O，下面对每一种I/O模型进行详细分析。")]),_._v(" "),t("h4",{attrs:{id:"_1-2-1-阻塞i-o模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-阻塞i-o模型"}},[_._v("#")]),_._v(" 1.2.1 阻塞I/O模型")]),_._v(" "),t("p",[_._v("阻塞I/O模型的通信过程示意如下图所示。")]),_._v(" "),t("p",[_._v("![截屏2022-01-24 下午10.53.47](https://gitee.com/WWWWWWWXQ/images/raw/master/JCP-JUC/截屏2022-01-24 下午10.53.47.png)")]),_._v(" "),t("p",[_._v("当用户进程调用了"),t("code",[_._v("recvfrom")]),_._v("这个系统调用，内核就开始了I/O的第一个阶段："),t("strong",[_._v("准备数据")]),_._v("。对于网络I/O来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包)，这个时候内核就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞，当数据准备好时，它就会将数据从内核拷贝到用户内存，然后返回结果，用户进程才解除阻塞的状态，重新运行起来。几乎所有的开发者第一次接触到的网络编程都是从"),t("code",[_._v("listen()")]),_._v("、"),t("code",[_._v("send()")]),_._v("，"),t("code",[_._v("recv()")]),_._v("等接口开始的，这些接口都是"),t("strong",[_._v("阻塞型")]),_._v("的。")]),_._v(" "),t("p",[_._v("阻塞I/O模型的特性总结如下表所示。")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("特点")]),_._v(" "),t("th",[_._v("特点1在I/O执行的两个阶段(等待数据和拷贝数据)都被阻")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("典型应用")]),_._v(" "),t("td",[_._v("阻塞Socket，Java BIO")])]),_._v(" "),t("tr",[t("td",[_._v("优点")]),_._v(" "),t("td",[_._v("进程阻塞挂起不消耗CPU资源，及时响应每个操作"),t("br"),_._v("实现难度低，开发应用较容易"),t("br"),_._v("适合并发量小的网络应用开发")])]),_._v(" "),t("tr",[t("td",[_._v("缺点")]),_._v(" "),t("td",[_._v("不适合并发量大的应用，因为一个请求I/O会阻塞进程"),t("br"),_._v("需要为每个请求分配一个处理进程(线程)以及时响应，系统开销大")])])])])])}),[],!1,null,null,null);v.default=e.exports}}]);